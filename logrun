#!/bin/bash

# 1. Initialize variables
SEPARATOR_INDEX=-1 # Use -1 to indicate no separator found
i=1                # Start counting arguments from 1 in Bash

# 2. Find the position of the separator '--'
for arg in "$@"; do
    if [[ "$arg" == "--" ]]; then
        SEPARATOR_INDEX=$((i - 1)) # Separator is found at index i-1
    fi
    i=$((i + 1))
done

# 3. Extract the command and logger arguments
if [ $SEPARATOR_INDEX -eq -1 ]; then
    # Case: No '--' found. Treat all arguments as the command.
    COMMAND_AND_ARGS=("$@")
    LOGGER_ARGS=()
    COMMAND_OFFSET=$# # All args are command, logger args start after the last arg
else
    # Case: '--' found.
    # Arguments for the command: from 1 up to SEPARATOR_INDEX elements
    COMMAND_AND_ARGS=("${@:1:$SEPARATOR_INDEX}")

    # Arguments for logger: from SEPARATOR_INDEX + 2 (skips '--')
    LOGGER_ARGS=("${@:$((SEPARATOR_INDEX + 2))}")
fi

# 4. Execute the command
# Using a temporary file to capture STDOUT and STDERR separately is safer,
# but capturing STDERR into a variable is fine for simple scripts like this.
# Note: We execute the command with arguments stored in the array.
ERROR=$("${COMMAND_AND_ARGS[@]}" 2>&1 >/dev/null)
errorCode=$?

# 5. Log the error if the command failed
if [ $errorCode -ne 0 ]; then
    # Log the error, using the extracted logger arguments
    # We pass $ERROR as the final log message content
    logger "${LOGGER_ARGS[@]}" "$ERROR"
    echo "$ERROR" >&2
    exit $errorCode
fi

exit 0
